import { join, parse } from "std/path/mod.ts";
import { EOL, walk } from "std/fs/mod.ts";

import { type EntryPoints } from "../bundler/bundler.ts";

export type Island = [string, string];
type IslandManifestConfig = {
  path: string;
};

export async function islandsManifest(
  config: IslandManifestConfig,
): Promise<Island[]> {
  const _islands: Island[] = [];
  let _i = 0;

  for await (
    const entry of walk(config.path, {
      includeDirs: false,
      match: [/(.+\$\.tsx)$/],
    })
  ) {
    _islands.push([entry.path, `$I${_i}`]);
    _i++;
  }

  await writeManifest(_islands);
  return _islands;
}

export function mapIslandsToEntryPoints(islands: Island[]): EntryPoints {
  const _entryPoints: EntryPoints = {};
  for (const [name] of islands) {
    _entryPoints[`island-${parse(name).name}`] = `./${name}`;
  }
  return _entryPoints;
}

async function writeManifest(islands: Island[]) {
  const content =
    `// This file is automatically generated by the Cargo Parcel "islands" command for Cargo Load. Do not edit it manually.
${islands?.length ? imports(islands) : ""}
${exports(islands)}`;
  try {
    const existingManifest = await Deno.readTextFile(
      join(".manifest", ".islands.ts"),
    );
    if (existingManifest !== content) {
      return await Deno.writeTextFile(
        join(".manifest", ".islands.ts"),
        content,
      );
    }
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      return await Deno.writeTextFile(
        join(".manifest", ".islands.ts"),
        content,
      );
    }
    throw e;
  }
}

function imports(islands: Island[]) {
  return islands.map((island) =>
    `import ${island[1]} from "../${island[0]}";${EOL.LF}`
  ).join("");
}

function exports(islands: Island[]) {
  return `export default {
${
    islands.map((island) => `  "${island[0]}": ${island[1]},${EOL.LF}`).join("")
  }}`;
}
